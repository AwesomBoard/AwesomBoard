rules_version = "2";
service cloud.firestore {
    match /databases/{database}/documents {
        // The rules used for testing are the production rules, with the addition that we have a /foo/ collection to test our DAO mock.
        match /foo/{document=**} {
            // only used for testing purposes, do not push to production
            allow read, write: if true;
        }
        // From here, the rest of the file matches with firestore.rules
        match /{document=**} {
            // by default, nothing can be read or written unless explicitly authorized
            allow read, write: if false;
        }
        match /errors/{errorId} {
            // Anybody can read, create and update errors
            allow create: if true;
            allow update: if true;
            allow read: if true;
        }
        match /chats/lobby {
            allow create: if userIsVerified();
        }
        match /chats/{id} {
            allow create, delete: if userIsVerified() && partExistsAndOwnedByCurrentUser(id);
            // Anyone can delete the chat in case the creator timed out
            allow delete: if userIsVerified() && debug(hasTimedOut(debug(creatorOf(id))));
        }
        function partExistsAndOwnedByCurrentUser(partId) {
            let joiner = get(/databases/$(database)/documents/joiners/$(partId)).data;
            return joiner != null && joiner.creator.id == request.auth.uid;
        }
        match /chats/{chatId}/messages/{messageId} {
            allow create: if userIsVerified() && isValidMessage(request.resource.data);
            allow delete: if userIsVerified() && isMessageAuthor(resource.data);
            allow update: if userIsVerified() && isMessageAuthor(resource.data) && isValidMessage(request.resource.data);
            allow read: if userIsVerified();
        }
        function isValidMessage(message) {
            return hasField(message, 'content') &&
                   hasField(message, 'sender') &&
                   isMessageAuthor(message) &&
                   usernameOf(message.sender.id) == message.sender.name &&
                   hasField(message, 'postedTime');
        }
        function hasField(data, field) {
            return field in data && data[field] != null;
        }
        function isMessageAuthor(message) {
            return request.auth.uid == message.sender.id
        }
        function usernameOf(uid) {
            return get(/databases/$(database)/documents/users/$(uid)).data.username
        }
        match /users/{userId} {
            // Only an authenticated account can create its own user, and they cannot directly be verified
            allow create: if isOwner(userId) && request.resource.data.verified == false
            // Only the user can change its fields
            // Moreover, the username cannot be changed once set
            // And the verified field can only be changed to true if the user has a username and has its email verified
            allow update: if isOwner(userId) && doesNotModifyUsernameIfSet() && onlyModifiesVerifiedFieldIfUserIsVerified();
            // Anybody can read the fields of a user.
            // This is because before user creation, we need to check if the username is free.
            allow read: if true;
        }
        function isOwner(userId) {
            return request != null &&
                request.auth != null &&
                request.auth.uid == userId;
        }
        function doesNotModifyUsernameIfSet() {
            let usernameAlreadySet = hasField(resource.data, 'username');
            let usernameBeingSet = hasField(request.resource.data, 'username');
            // It sometimes happens that firebase sends the username as part as updates, even though it is not actually updated. Hence, we accept usernames as part of updates, only if it doesn't change.
            let doesNotChange = preservesField('username');
            return usernameAlreadySet == false || usernameBeingSet == false || doesNotChange;
        }
        function onlyModifiesVerifiedFieldIfUserIsVerified() {
            let verifiedKeptSameValue = (resource.data.verified == request.resource.data.verified);
            let verifiedSetToTrueAfterVerification = (resource.data.verified == false && userIsVerified() && resource.data.username != null);
            return verifiedKeptSameValue || verifiedSetToTrueAfterVerification
        }
        match /parts/{id} {
            // Any verified user can create a part with the proper fields set, and has to be the creator
            allow create: if userIsVerified() &&
                             // turn can be -1 in case of a new part, 0 in case of a rematch
                             (request.resource.data.turn == -1 || request.resource.data.turn == 0) &&
                             hasField(request.resource.data, 'typeGame') &&
                             request.resource.data.listMoves == [] &&
                             // creator must be one of the players (could be playerOne in case of rematch)
                             (request.auth.uid == request.resource.data.playerZero.id ||
                              hasField(request.resource.data, 'playerOne') && request.auth.uid == request.resource.data.playerOne.id);
            // The owner of a part can delete it, if it has not started
            allow delete: if userIsVerified() &&
                             creatorOf(id).id == request.auth.uid &&
                             partHasStarted(resource.data) == false;
            // Anyone can delete a part if the owner has timed out and the part has not started
            allow delete: if userIsVerified() &&
                             hasTimedOut(creatorOf(id)) &&
                             partHasStarted(resource.data) == false;
            // A verified user who is the chosen opponent can start the part
            allow update: if userIsVerified() &&
                             partHasStarted(resource.data) == false &&
                             partHasStarted(request.resource.data) &&
                             preservesField('typeGame') &&
                             safeLastUpdate(resource.data.lastUpdate, request.resource.data.lastUpdate) &&
                             userIsChosenOpponentInJoiner(id) &&
                             validPlayerSelection(id, request.resource.data);
            // A player can update the part as long as it preserves the right fields
            // (typeGame, playerZero, playerOne, beginning) and performs safe updates:
            // - lastUpdate must be updated monotonously by the corresponding player
            // - turn can only be made +1 (usual turn), -1 (take back), or -2 (take back)
            allow update: if userIsVerified() &&
                             partHasStarted(resource.data) &&
                             userIsPlayer(resource.data) &&
                             preservesField('typeGame') &&
                             preservesField('playerZero') &&
                             preservesField('playerOne') &&
                             preservesField('beginning') &&
                             safeTimeUpdate(resource.data.playerZero, 'remainingMsForZero') &&
                             safeTimeUpdate(resource.data.playerOne, 'remainingMsForOne') &&
                             (preservesField('turn') || safeTurnUpdate(resource.data.turn, request.resource.data.turn)) &&
                             (safeLastUpdate(resource.data.lastUpdate, request.resource.data.lastUpdate));
            // All verified user can read parts (needed for the lobby)
            allow read: if userIsVerified();
        }
        function safeTimeUpdate(player, remainingMsFieldName) {
            let timeUnchanged = preservesField(remainingMsFieldName);
            return timeUnchanged ||
                   safeTimeDecrease(player, remainingMsFieldName) ||
                   safeTimeIncrease(player, remainingMsFieldName);
        }
        function safeTimeDecrease(player, remainingMsFieldName) {
            let timeDecreased = request.resource.data[remainingMsFieldName] < resource.data[remainingMsFieldName];
            let isOwnTime = request.auth.uid == player.id;
            return timeDecreased && isOwnTime;
        }
        function safeTimeIncrease(player, remainingMsFieldName) {
            let timeIncreased = request.resource.data[remainingMsFieldName] > resource.data[remainingMsFieldName];
            let isNotOwnTime = request.auth.uid != player.id;
            return timeIncreased && isNotOwnTime;
        }
        function validPlayerSelection(partId, partUpdate) {
            let joiner = get(/databases/$(database)/documents/joiners/$(partId)).data;
            let playerZeroIsCreator = playerEquals(partUpdate.playerZero, joiner.creator);
            let playerZeroIsChosenOpponent = playerEquals(partUpdate.playerZero, joiner.chosenOpponent);
            let playerOneIsCreator = playerEquals(partUpdate.playerOne, joiner.creator);
            let playerOneIsChosenOpponent = playerEquals(partUpdate.playerOne, joiner.chosenOpponent);
            return (playerZeroIsCreator || playerZeroIsChosenOpponent) && (playerOneIsCreator || playerOneIsChosenOpponent);
        }
        function playerEquals(player, otherPlayer) {
            return player.id == otherPlayer.id && player.name == otherPlayer.name;
        }
        function userIsChosenOpponentInJoiner(partId) {
            let joiner = get(/databases/$(database)/documents/joiners/$(partId)).data;
            return hasField(joiner, 'chosenOpponent') && joiner.chosenOpponent.id == request.auth.uid;
        }
        function userIsPlayer(part) {
            let userIsPlayerZero = part.playerZero.id == request.auth.uid;
            let userIsPlayerOne = hasField(part, 'playerOne') && part.playerOne.id == request.auth.uid;
            return userIsPlayerZero || userIsPlayerOne;
        }
        function safeTurnUpdate(oldTurn, newTurn) {
            return (newTurn == oldTurn + 1) || (newTurn == oldTurn - 1) || (newTurn == oldTurn - 2);
        }
        function safeLastUpdate(oldLastUpdate, newLastUpdate) {
            let legitimatePlayerZeroUpdate = newLastUpdate.player == 0 && resource.data.playerZero.id == request.auth.uid;
            let legitimatePlayerOneUpdate = hasField(resource.data, 'playerOne') && newLastUpdate.player == 1 && resource.data.playerOne.id == request.auth.uid;
            let indexIncremented = newLastUpdate.index == oldLastUpdate.index + 1;
            return (legitimatePlayerZeroUpdate || legitimatePlayerOneUpdate || partHasStarted(resource.data) == false) && indexIncremented;
        }
        function partHasStarted(part) {
            // A part is started when the beginning field is set
            return hasField(part, 'beginning');
        }
        function hasTimedOut(user) {
            let userDoc = get(/databases/$(database)/documents/users/$(user.id)).data;
            let timedOut = request.time.time() > userDoc.lastUpdateTime.time() + duration.value(10, 's');
            return timedOut;
        }
        match /joiners/{partId} {
            // Any verified user can create a joiner as long as they are themselves creator and if the corresponding part exists
            allow create: if userIsVerified() &&
                             userIsCreatorWithValidName(request.resource.data) &&
                             exists(/databases/$(database)/documents/parts/$(partId));
            // The creator can delete a joiner if the part has not started
            allow delete: if userIsVerified() && userIsCreator(resource.data) && joinerHasNotStarted(resource.data);
            // Anybody else can delete a joiner only if the creator has timed out and the part has not started
            allow delete: if userIsVerified() && hasTimedOut(creatorOf(partId)) && joinerHasNotStarted(resource.data);
            // The creator can change all fields except 'creator', or changing partStatus to STARTED (3) or FINISHED (4), until the part starts
            allow update: if userIsVerified() && userIsCreator(resource.data) &&
                             preservesField('creator') &&
                             resource.data.partStatus < 3 && request.resource.data.partStatus != 3;
            // The creator can only change partStatus (to finished) once the part has been started
            allow update: if userIsVerified() && userIsCreator(resource.data) &&
                             resource.data.partStatus == 3 &&
                             request.resource.data.partStatus == 4 &&
                             preservesField('creator') &&
                             preservesField('firstPlayer') &&
                             preservesField('partType') &&
                             preservesField('maximalMoveDuration') &&
                             preservesField('totalPartDuration') &&
                             preservesField('chosenOpponent')
            // For anybody else:
            //   - the chosen opponent can change the config from PROPOSED to STARTED
            allow update: if validJoinerUpdate() &&
                             preservesField('chosenOpponent') &&
                             acceptsConfig()
            //   - the chosen opponent can remove itself from the corresponding field
            allow update: if validJoinerUpdate() &&
                             preservesField('partStatus') &&
                             removesOneSelfFromChosenOpponent();
            // Any verified user can read a joiner
            allow read: if userIsVerified();
        }
        function validJoinerUpdate() {
            return userIsVerified() &&
                userIsChosenOpponent() &&
                preservesField('creator') &&
                preservesField('firstPlayer') &&
                preservesField('partType') &&
                preservesField('maximalMoveDuration') &&
                preservesField('totalPartDuration');
        }
        function joinerHasNotStarted(joiner) {
            return joiner.partStatus < 3;
        }
        match /joiners/{partId}/candidates/{userId} {
            // Users can only add themselves to the candidate list if they are not the creator and if they use the right username
            // We also allow updates in this way, in case someone tries to join the part twice
            allow create, update: if userIsVerified() && userId == request.auth.uid &&
                                     request.auth.uid != creatorOf(partId).id &&
                                     request.resource.data.name == usernameOf(request.auth.uid) &&
                                     request.resource.data.id == request.auth.uid;
            // Users can only delete themselves
            allow delete: if userIsVerified() && userId == request.auth.uid;
            // Any verified user can read the candidate list
            allow read: if userIsVerified();
        }
        function creatorOf(partId) {
            return get(/databases/$(database)/documents/joiners/$(partId)).data.creator;
        }
        function userIsVerified() {
            return request != null &&
                   request.auth != null &&
                   request.auth.uid != null &&
                   request.auth.token.email_verified == true;
        }
        function userIsCreator(joiner) {
            return joiner.creator != null &&
                   joiner.creator.id == request.auth.uid;
        }
        function userIsCreatorWithValidName(joiner) {
            return userIsCreator(joiner) &&
                   joiner.creator.name == usernameOf(request.auth.uid);
        }
        function preservesField(fieldName) {
            // A field is preserved if it is not part of the update
            // or if the same value is given in the update
            return !(fieldName in request.resource.data) || (request.resource.data[fieldName] == resource.data[fieldName]);
        }
        function userIsChosenOpponent() {
            let uid = request.auth.uid;
            return hasField(resource.data, 'chosenOpponent') && resource.data.chosenOpponent.id == uid;
        }
        function acceptsConfig() {
            return resource.data.partStatus == 2 && // CONFIG_PROPOSED
                   request.resource.data.partStatus == 3; // PART_STARTED
        }
        function removesOneSelfFromChosenOpponent() {
            let uid = request.auth.uid;
            return hasField(resource.data, 'chosenOpponent') &&
                   resource.data.chosenOpponent.id == uid &&
                   request.resource.data.chosenOpponent == null;
        }
    }
}
