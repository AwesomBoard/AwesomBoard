rules_version = "2";
service cloud.firestore {
    match /databases/{database}/documents {
        // The rules used for testing are the production rules, with the addition that we have a /foo/ collection to test our DAO mock.
        match /foo/{document=**} {
            // only used for testing purposes, do not push to production
            allow read, write: if true;
        }
        // From here, the rest of the file matches with firestore.rules
        // Unfortunately, firebase does not support imports so we have to copy it manually
        match /{document=**} {
            // by default, nothing can be read or written unless explicitly authorized
            allow read, write: if false;
        }
        match /errors/{errorId} {
            // Anybody can read, create and update errors
            allow create: if true;
            allow update: if true;
            allow read: if true;
        }
        match /chats/lobby {
            allow create: if userIsVerified();
        }
        match /chats/{chatId} {
            allow create, delete: if userIsVerified() && partExistsAndOwnedByCurrentUser(chatId);
        }
        function partExistsAndOwnedByCurrentUser(partId) {
            let joiner = get(/databases/$(database)/documents/joiners/$(partId)).data;
            return joiner != null && joiner.creator.id == request.auth.uid;
        }
        match /chats/{chatId}/messages/{messageId} {
            allow create: if userIsVerified() && isValidMessage(request.resource.data);
            allow delete: if userIsVerified() && isMessageAuthor(resource.data);
            allow update: if userIsVerified() && isMessageAuthor(resource.data) && isValidMessage(request.resource.data);
            allow read: if userIsVerified();
        }
        function isValidMessage(message) {
            return hasField(message, 'content') &&
                   hasField(message, 'sender') &&
                   isMessageAuthor(message) &&
                   usernameOf(message.sender.id) == message.sender.name &&
                   hasField(message, 'postedTime');
        }
        function hasField(data, field) {
            return field in data && data[field] != null;
        }
        function isMessageAuthor(message) {
            return request.auth.uid == message.sender.id
        }
        function usernameOf(uid) {
            return get(/databases/$(database)/documents/joueurs/$(uid)).data.username
        }
        // joueurs will be renamed to users
        match /joueurs/{userId} {
            // Only an authenticated account can create its own user, and they cannot directly be verified
            allow create: if isOwner(userId) && request.resource.data.verified == false
            // Only the user can change its fields
            // Moreover, the username cannot be changed once set
            // And the verified field can only be changed to true if the user has a username and has its email verified
            allow update: if isOwner(userId) && doesNotModifyUsernameIfSet() && onlyModifiesVerifiedIfVerified();
            // Anybody can read the fields of a user.
            // This is because before user creation, we need to check if the username is free.
            allow read: if true;
        }
        function isOwner(userId) {
            return request != null &&
                request.auth != null &&
                request.auth.uid == userId;
        }
        function doesNotModifyUsernameIfSet() {
            let usernameNotYetSet = hasField(resource.data, 'username') == false;
            let usernameBeingSet = hasField(request.resource.data, 'username');
            // It sometimes happens that firebase sends the username as part as updates, even though it is not actually updated. Hence, we accept usernames as part of updates, only if it doesn't change.
            let doesNotChange = hasField(resource.data, 'username') && hasField(request.resource.data, 'username') && resource.data['username'] == request.resource.data['username'];
            return usernameNotYetSet || usernameBeingSet == false || doesNotChange;
        }
        function onlyModifiesVerifiedIfVerified() {
            return hasField(request.resource.data, 'verified') == false ||
                   request.resource.data.verified == false ||
                   (userIsVerified() && resource.data.username != null);
        }
        match /parties/{id} {
            allow write, read: if userIsVerified();
        }
        match /joiners/{partId} {
            // Anybody can create a joiner as long as they are themselves creator and if the corresponding part exists
            allow create: if userIsVerified() && userIsCreator(request.resource.data) && exists(/databases/$(database)/documents/parties/$(partId));
            // The creator can change all fields except:
            //   - changing partStatus to STARTED (3)
            //   - changing candidates
            allow update: if userIsVerified() &&
                             userIsCreator(resource.data) &&
                             request.resource.data.partStatus != 3 && preservesField('candidates');
            // Anybody else than the creator can add or remove themselves to the candidate list, leaving the other candidates untouched.
            // Moreover, a chosenPlayer can remove itself (in case they leave the joiner)
            // Finally, the chosenPlayer can change the config from PROPOSED to STARTED
            // No other field can be touched
            allow update: if userIsVerified() &&
                             !userIsCreator(resource.data) &&
                             preservesField('creator') && preservesField('firstPlayer') && preservesField('partType') && preservesField('maximalMoveDuration') && preservesField('totalPartDuration') &&
                             (preservesField('candidates') || addsOneSelfToCandidates()) &&
                             (preservesField('partStatus') || changePartStatusAsChosenPlayer()) &&
                             (preservesField('chosenPlayer') || removesOneSelfFromChosenPlayer());

            // Any verified user can read a joiner
            allow read: if userIsVerified();
        }
        function userIsVerified() {
            return request != null &&
                   request.auth != null &&
                   request.auth.uid != null &&
                   request.auth.token.email_verified == true;
        }
        function userIsCreator(joiner) {
            return joiner.creator != null &&
                   joiner.creator.id == request.auth.uid &&
                   debug(joiner.creator.name) == debug(usernameOf(request.auth.uid));
        }
        function isCurrentUser(user) {
            let uid = request.auth.uid;
            let username = get(/databases/$(database)/documents/joueurs/$(uid)).data.username;
            return user.id == uid && user.name == username;
        }
        function preservesField(field) {
            return !(field in request.resource.data) || (request.resource.data[field] == resource.data[field]);
        }
        function addsOneSelfToCandidates() {
            // TODO: there's not a lot we can ensure here. Check firebase doc to see if we can do more
            // TODO: may need to look at doc here, we can't seem to compute the length!
            return true;
//            let oldLength = debug(len(resource.data.candidates));
//            let newLength = debug(request.resource.data.candidates.size);
//            return debug(newLength) == debug(oldLength) + 1 &&
//                   isCurrentUser(debug(request.resource.data.candidates)[newLength-1]);
        }
        function changePartStatusAsChosenPlayer() {
            let uid = request.auth.uid;
            let username = get(/databases/$(database)/documents/joueurs/$(uid)).data.username;
            return resource.data.chosenPlayer == username &&
                   resource.data.partStatus == 2 && // CONFIG_PROPOSED
                   request.resource.data.partStatus == 3; // PART_STARTED
        }
        function removesOneSelfFromChosenPlayer() {
            let uid = request.auth.uid;
            let username = get(/databases/$(database)/documents/joueurs/$(uid)).data.username;
            return resource.data.chosenPlayer == username &&
                   request.resource.data.chosenPlayer == null;
        }
    }
}
