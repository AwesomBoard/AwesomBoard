rules_version = "2";
service cloud.firestore {
    match /databases/{database}/documents {
        function hasField(data, field) {
            return field in data && data[field] != null;
        }
        function preservesField(fieldName) {
            // A field is preserved if it is not part of the update
            // or if the same value is given in the update
            return !(fieldName in request.resource.data) || (request.resource.data[fieldName] == resource.data[fieldName]);
        }
        match /{document=**} {
            // by default, nothing can be read or written unless explicitly authorized
            allow read, write: if false;
        }
        match /errors/{errorId} {
            // Anybody can read, create and update errors
            allow create: if true;
            allow update: if true;
            allow read: if true;
        }
        match /chats/lobby {
            allow create: if userIsVerified();
        }
        match /chats/{id} {
            allow create, delete: if userIsVerified() && partExistsAndOwnedByCurrentUser(id);
            // Anyone can delete the chat in case the creator timed out
            allow delete: if userIsVerified() && hasTimedOut(creatorOf(id));
        }
        function partExistsAndOwnedByCurrentUser(partId) {
            let configRoom = get(/databases/$(database)/documents/config-room/$(partId)).data;
            return configRoom != null && configRoom.creator.id == request.auth.uid;
        }
        match /chats/{chatId}/messages/{messageId} {
            allow create: if verifiedUserPostsValidMessage(request.resource.data);
            allow delete: if verifiedUserIsMessageAuthor(resource.data);
            allow update: if verifiedUserUpdatesMessage(resource.data, request.resource.data);
            allow read: if userIsVerified();
        }
        function verifiedUserPostsValidMessage(message) {
            return userIsVerified() && isValidMessage(message);
        }
        function isValidMessage(message) {
            return hasField(message, 'content') &&
                   hasField(message, 'sender') &&
                   isMessageAuthorWithCorrectUsername(message) &&
                   hasField(message, 'postedTime');
        }
        function isMessageAuthorWithCorrectUsername(message) {
            return isMessageAuthor(message) &&
                   usernameOf(message.sender.id) == message.sender.name;
        }
        function isMessageAuthor(message) {
            return request.auth.uid == message.sender.id
        }
        function verifiedUserIsMessageAuthor(message) {
            return userIsVerified() && isMessageAuthor(message)
        }
        function usernameOf(uid) {
            return get(/databases/$(database)/documents/users/$(uid)).data.username
        }
        function verifiedUserUpdatesMessage(message, update) {
            return userIsVerified() &&
                isMessageAuthor(message) &&
                preservesField('sender') &&
                isValidMessage(update);
        }
        match /users/{userId} {
            allow create: if authenticatedUserCreatesUnverifiedUser(userId, request.resource.data);
            allow update: if authenticatedUserUpdatesUser(userId, resource.data, request.resource.data);
            // Anybody can read the fields of a user.
            // This is because before user creation, we need to check if the username is free.
            allow read: if true;
        }
        function authenticatedUserCreatesUnverifiedUser(userId, update) {
            // Only an authenticated account can create its own user, and they cannot directly be verified
            return isAuthenticated() && isOwner(userId) && update.verified == false;
        }
        function isAuthenticated() {
            return request != null && request.auth != null;
        }
        function isOwner(userId) {
            return request.auth.uid == userId;
        }
        function authenticatedUserUpdatesUser(userId, user, update) {
            // Only the user can change its fields
            // Moreover, the username cannot be changed once set
            // And the verified field can only be changed to true if the user has a username and has its email verified
            return isAuthenticated() &&
                isOwner(userId) &&
                doesNotModifyUsernameIfSet(user, update) &&
                onlyModifiesVerifiedFieldIfUserIsVerified(user, update);
        }
        function doesNotModifyUsernameIfSet(user, update) {
            let usernameAbsent = hasField(user, 'username') == false;
            let usernameUnchanged = hasField(update, 'username') == false;
            // It sometimes happens that firebase sends the username as part as updates,
            // even though it is not actually updated.
            // Hence, we accept usernames as part of updates, only if it doesn't change.
            let doesNotChange = preservesField('username');
            return usernameAbsent || usernameUnchanged || doesNotChange;
        }
        function onlyModifiesVerifiedFieldIfUserIsVerified(user, update) {
            let verifiedKeptSameValue = user.verified == update.verified;
            let verifiedSetToTrueAfterVerification = user.verified == false && userIsVerified() && user.username != null;
            return verifiedKeptSameValue || verifiedSetToTrueAfterVerification
        }
        match /parts/{id} {
            allow create: if creatorCreatesPart(request.resource.data);
            allow delete: if creatorDeletesUnstartedPart(id, resource.data);
            allow delete: if verifiedUserDeletesPartAfterCreatorTimeout(id, resource.data);
            allow update: if chosenOpponentStartsPart(id, resource.data, request.resource.data);
            allow update: if playerPerformsMove(resource.data, request.resource.data);
            allow update: if playerPerformsNonMoveUpdate(resource.data, request.resource.data);
            // All verified user can read parts (needed for the lobby)
            allow read: if userIsVerified();
        }
        function creatorCreatesPart(part) {
            // Any verified user can create a part with the proper fields set, and has to be the creator
            // turn can be -1 in case of a new part, 0 in case of a rematch
            let turnForNewPartOrRematch = part.turn == -1 || part.turn == 0;
            // creator must be one of the players (could be playerOne in case of rematch)
            let creatorIsPlayerZero = request.auth.uid == part.playerZero.id;
            let creatorIsPlayerOne = hasField(part, 'playerOne') && request.auth.uid == part.playerOne.id;
            let creatorIsPlayer = creatorIsPlayerZero || creatorIsPlayerOne;

            return userIsVerified() &&
                turnForNewPartOrRematch &&
                hasField(part, 'typeGame') &&
                part.listMoves == [] &&
                creatorIsPlayer;
        }
        function creatorDeletesUnstartedPart(id, part) {
            // The owner of a part can delete it, if it has not started
            return userIsVerified() &&
                creatorOf(id).id == request.auth.uid &&
                partHasStarted(part) == false;
        }
        function verifiedUserDeletesPartAfterCreatorTimeout(id, part) {
            // Anyone can delete a part if the owner has timed out and the part has not started
            return userIsVerified() &&
                hasTimedOut(creatorOf(id)) &&
                partHasStarted(part) == false;
        }
        function playerPerformsMove(part, update) {
            // A player can perform a move
            let decreasesPlayerZeroTime = safeTimeDecrease(part.playerZero, 'remainingMsForZero', part, update);
            let preservesPlayerZeroTime = preservesField('remainingMsForZero');
            let decreasesPlayerOneTime = safeTimeDecrease(part.playerOne, 'remainingMsForOne', part, update);
            let preservesPlayerOneTime = preservesField('remainingMsForOne');
            let safeTimeDecrease = (part.turn == 0 && preservesPlayerOneTime && preservesPlayerZeroTime) ||
                (userIsPlayerOne(part) && decreasesPlayerZeroTime && preservesPlayerOneTime) ||
                (userIsPlayerZero(part) && preservesPlayerZeroTime && decreasesPlayerOneTime);
            let isUserTurn = (part.turn % 2 == 0 && userIsPlayerZero(part)) ||
                (part.turn % 2 == 1 && userIsPlayerOne(part));
            return isValidPartUpdateDuringGame(part) &&
                part.listMoves != update.listMoves &&
                safeTimeDecrease &&
                safeTurnIncrease(part.turn, update.turn) &&
                safeLastUpdate(part, update) &&
                isUserTurn;
        }
        function playerPerformsNonMoveUpdate(part, update) {
            // A player can do other requests such as take backs, etc. if there is no move done
            let safeTimeUpdatePlayerZero = preservesField('remainingMsForZero') ||
                (userIsPlayerOne(part) && safeTimeIncrease(part.playerZero, 'remainingMsForZero', part, update));
            let safeTimeUpdatePlayerOne = preservesField('remainingMsForOne') ||
                (userIsPlayerZero(part) && safeTimeIncrease(part.playerOne, 'remainingMsForOne', part, update));
            return isValidPartUpdateDuringGame(part) &&
                safeTimeUpdatePlayerZero && safeTimeUpdatePlayerOne &&
                (preservesField('turn') || safeTurnDecrease(part.turn, update.turn)) &&
                onlyAcceptsDrawIfProposed(part, update) &&
                safeLastUpdate(part, update);
        }
        function onlyAcceptsDrawIfProposed(part, update) {
            // 6 = draw agreed by zero
            // 7 = draw agreed by one
            let acceptsDraw = hasField(update, 'result') &&
                ((userIsPlayerZero(part) && update.result == 6) ||
                 (userIsPlayerOne(part) && update.result == 7));
            let drawWasProposed = hasField(part, 'request') && part.request.code == 'DrawProposed';
            return acceptsDraw == false ||
                (acceptsDraw && drawWasProposed);
        }
        function isValidPartUpdateDuringGame(part) {
            return userIsVerified() &&
                partHasStarted(part) &&
                userIsPlayer(part) &&
                preservesField('typeGame') &&
                preservesField('playerZero') &&
                preservesField('playerOne') &&
                preservesField('beginning');
        }
        function chosenOpponentStartsPart(partId, part, update) {
            // A verified user who is the chosen opponent can start the part
            let configRoom = get(/databases/$(database)/documents/config-room/$(partId)).data;
            return userIsVerified() &&
                partHasStarted(part) == false &&
                partHasStarted(update) &&
                preservesField('typeGame') &&
                preservesField('winner') &&
                preservesField('loser') &&
                preservesField('result') &&
                preservesField('scorePlayerZero') &&
                preservesField('scorePlayerOne') &&
                update.turn == 0 &&
                safeLastUpdate(part, update) &&
                userIsChosenOpponentInConfigRoom(configRoom) &&
                validPlayerSelection(configRoom, update) &&
                // The time is set using the values from the config room
                update.remainingMsForZero == configRoom.totalPartDuration * 1000 &&
                update.remainingMsForOne == configRoom.totalPartDuration * 1000;
        }
        function safeTimeDecrease(player, remainingMsFieldName, part, update) {
            let timeDecreased = update[remainingMsFieldName] < part[remainingMsFieldName];
            let isNotOwnTime = request.auth.uid != player.id;
            return timeDecreased && isNotOwnTime;
        }
        function safeTimeIncrease(player, remainingMsFieldName, part, update) {
            let timeIncreased = update[remainingMsFieldName] > part[remainingMsFieldName];
            let isNotOwnTime = request.auth.uid != player.id;
            return timeIncreased && isNotOwnTime;
        }
        function validPlayerSelection(configRoom, partUpdate) {
            let playerZeroIsCreator = playerEquals(partUpdate.playerZero, configRoom.creator);
            let playerZeroIsChosenOpponent = playerEquals(partUpdate.playerZero, configRoom.chosenOpponent);
            let playerOneIsCreator = playerEquals(partUpdate.playerOne, configRoom.creator);
            let playerOneIsChosenOpponent = playerEquals(partUpdate.playerOne, configRoom.chosenOpponent);
            return (playerZeroIsCreator || playerZeroIsChosenOpponent) && (playerOneIsCreator || playerOneIsChosenOpponent);
        }
        function playerEquals(player, otherPlayer) {
            return player.id == otherPlayer.id && player.name == otherPlayer.name;
        }
        function userIsChosenOpponentInConfigRoom(configRoom) {
            return hasField(configRoom, 'chosenOpponent') && configRoom.chosenOpponent.id == request.auth.uid;
        }
        function userIsPlayer(part) {
            return userIsPlayerZero(part) || userIsPlayerOne(part);
        }
        function userIsPlayerZero(part) {
            return part.playerZero.id == request.auth.uid;
        }
        function userIsPlayerOne(part) {
            return hasField(part, 'playerOne') && part.playerOne.id == request.auth.uid;
        }
        function safeTurnIncrease(oldTurn, newTurn) {
            return newTurn == oldTurn + 1;
        }
        function safeTurnDecrease(oldTurn, newTurn) {
            return (newTurn == oldTurn - 1) || (newTurn == oldTurn - 2);
        }
        function safeLastUpdate(part, update) {
            let legitimatePlayerZeroUpdate = update.lastUpdate.player == 0 && part.playerZero.id == request.auth.uid;
            let legitimatePlayerOneUpdate = hasField(part, 'playerOne') &&
                update.lastUpdate.player == 1 &&
                part.playerOne.id == request.auth.uid;
            let indexIncremented = update.lastUpdate.index == part.lastUpdate.index + 1;
            return (legitimatePlayerZeroUpdate || legitimatePlayerOneUpdate || partHasStarted(part) == false) && indexIncremented;
        }
        function partHasStarted(part) {
            // A part is started when the beginning field is set
            return hasField(part, 'beginning');
        }
        function hasTimedOut(user) {
            let userDoc = get(/databases/$(database)/documents/users/$(user.id)).data;
            let timedOut = request.time.time() > userDoc.lastUpdateTime.time() + duration.value(10, 's');
            return timedOut;
        }
        match /config-room/{partId} {
            allow create: if creatorCreatesConfigRoom(partId, request.resource.data);
            allow delete: if creatorDeletesConfigRoom(resource.data);
            allow delete: if observerDeletesConfigRoom(partId, resource.data);
            allow update: if creatorUpdatesPartInCreation(resource.data, request.resource.data);
            allow update: if creatorChangesPartStatusToFinished(resource.data, request.resource.data);
            allow update: if chosenOpponentAcceptsConfig(resource.data, request.resource.data);
            allow update: if chosenOpponentLeaves(resource.data, request.resource.data)
            // Any verified user can read a config room
            allow read: if userIsVerified();
        }
        function creatorCreatesConfigRoom(partId, configRoom) {
            // Any verified user can create a configRoom as long as they are themselves creator and a corresponding part exists
            return userIsVerified() &&
                userIsCreatorWithValidName(configRoom) &&
                exists(/databases/$(database)/documents/parts/$(partId));
        }
        function creatorDeletesConfigRoom(configRoom) {
            // The creator can delete a config room if the part has not started
            return userIsVerified() && userIsCreator(configRoom) && configStillOngoing(configRoom);
        }
        function observerDeletesConfigRoom(partId, configRoom) {
            // Anybody else can delete a config room only if the creator has timed out and the part has not started
            return userIsVerified() && hasTimedOut(creatorOf(partId)) && configStillOngoing(configRoom);
        }
        function creatorUpdatesPartInCreation(configRoom, update) {
            // The creator can change all fields except 'creator', or changing partStatus to STARTED (3) or FINISHED (4), until the part starts
            return userIsVerified() && userIsCreator(configRoom) &&
                preservesField('creator') &&
                configRoom.partStatus < 3 && update.partStatus != 3;
        }
        function creatorChangesPartStatusToFinished(oldConfigRoom, newConfigRoom) {
            // The creator can only change partStatus (to finished) once the part has been started
            return userIsVerified() && userIsCreator(oldConfigRoom) &&
                oldConfigRoom.partStatus == 3 &&
                newConfigRoom.partStatus == 4 &&
                preservesCreationOnlyFields() &&
                preservesField('chosenOpponent');
        }
        function chosenOpponentAcceptsConfig(configRoom, update) {
            //  The chosen opponent can change the config from PROPOSED to STARTED
            return validChosenOpponentConfigRoomUpdate(configRoom) &&
                preservesField('chosenOpponent') &&
                acceptsConfig(configRoom, update);
        }
        function chosenOpponentLeaves(configRoom, update) {
            //   - the chosen opponent can remove itself from the corresponding field
            return validChosenOpponentConfigRoomUpdate(configRoom) &&
                preservesField('partStatus') &&
                removesOneSelfFromChosenOpponent(configRoom, update);
        }
        function validChosenOpponentConfigRoomUpdate(configRoom) {
            return userIsVerified() &&
                userIsChosenOpponentInConfigRoom(configRoom) &&
                preservesCreationOnlyFields();
        }
        function preservesCreationOnlyFields() {
            return preservesField('creator') &&
                preservesField('firstPlayer') &&
                preservesField('partType') &&
                preservesField('maximalMoveDuration') &&
                preservesField('totalPartDuration');
        }
        function configStillOngoing(configRoom) {
            return configRoom.partStatus < 3;
        }
        match /config-room/{partId}/candidates/{userId} {
            allow create, update: if candidateJoins(partId, userId, request.resource.data);
            allow delete: if candidateLeaves(userId);
            allow delete: if creatorKicksCandidate(partId);
            // Any verified user can read the candidate list
            allow read: if userIsVerified();
        }
        function candidateJoins(partId, userId, candidate) {
            // Users can only add themselves to the candidate list if they are not the creator and if they use the right username
            // We also allow updates in this way, in case someone tries to join the part twice
            return userIsVerified() &&
                userId == request.auth.uid &&
                request.auth.uid != creatorOf(partId).id &&
                candidate.name == usernameOf(request.auth.uid) &&
                candidate.id == request.auth.uid;
        }
        function candidateLeaves(userId) {
            // Users can only delete themselves
            return userIsVerified() && userId == request.auth.uid;
        }
        function creatorKicksCandidate(partId) {
            // Creator can remove any candidate
            return userIsVerified() &&
                request.auth.uid == creatorOf(partId).id;
        }
        function creatorOf(partId) {
            return get(/databases/$(database)/documents/config-room/$(partId)).data.creator;
        }
        function userIsVerified() {
            return request != null &&
                   request.auth != null &&
                   request.auth.uid != null &&
                   request.auth.token.email_verified == true;
        }
        function userIsCreator(configRoom) {
            return configRoom.creator.id == request.auth.uid;
        }
        function userIsCreatorWithValidName(configRoom) {
            return userIsCreator(configRoom) &&
                   configRoom.creator.name == usernameOf(request.auth.uid);
        }
        function acceptsConfig(configRoom, update) {
            return configRoom.partStatus == 2 && // CONFIG_PROPOSED
                   update.partStatus == 3; // PART_STARTED
        }
        function removesOneSelfFromChosenOpponent(configRoom, update) {
            let uid = request.auth.uid;
            return hasField(configRoom, 'chosenOpponent') &&
                configRoom.chosenOpponent.id == uid &&
                update.chosenOpponent == null;
        }
    }
}
